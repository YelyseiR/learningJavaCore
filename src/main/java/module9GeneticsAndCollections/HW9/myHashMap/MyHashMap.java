package main.java.module9GeneticsAndCollections.HW9.myHashMap;

public class MyHashMap {
    private class Node { //вкладений клас для зберігання пари ключ-значення
        Object key;
        Object value;
        Node next;

        public Node(Object key, Object value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    private Node[] array; //масив нод
    private int size; // розмір масиву котрий зберігає пари ключ-значення

    public MyHashMap() {
        array = new Node[5]; //початковий розмір масива
        size = 0;
    }

    public void put(Object key, Object value) {  //додає пару ключ + значення
        int hash = key.hashCode();  //хеш код ключа
        int index = hash & (array.length - 1); //індекс в масиві за хеш кодом

        Node node = array[index]; //вузол який займає вказаний індекс у масиві
        while (node != null) { //проходження однозв'язного списку вузлів
            if (node.key.equals(key)) { //у випадку якщо ключі рівні, то замінюємо значення
                node.value = value;
                return;
            }
            node = node.next; //перехід до наступного вузла
        }
        // Якщо запитуваного ключа ще немає у таблиці, то додати вузол на початок однозв'язного списку.
        // Новий вузол стає першим у списку, а його посилання next спрямоване на попередній перший вузол
        // (або null, якщо список був порожнім).
        Node newNode = new Node(key, value, array[index]);
        array[index] = newNode; //додавання нового вузла у масив
        size++;
    }

    public void remove(Object key) { //видаляє пару за ключем
        int hash = key.hashCode();  //хеш код ключа
        int index = hash & (array.length - 1); //індекс в масиві за хеш-кодом

        Node node = array[index];  //вузол, який займає вказаний індекс у масиві
        Node prevNode = null; // вузол, що стоїть перед поточним вузлом node у списку
        while (node != null) {   //проходимо по однозв'язному списку вузлів за допомогою вайл
            if (node.key.equals(key)) { //якщо ключі рівні, то поточний вузол ноди потрібно видалити
                if (prevNode == null) {  //якщо вузол був першим у списку, то змінюємо посилання на наступний
                    array[index] = node.next;
                } else {  //або якщо вузол був десь всередині списку, то змінюємо посилання попереднього вузла
                    prevNode.next = node.next;
                }
                size--;
                return;
            }
            prevNode = node;  // поточний вузол стає попереднім для наступного циклу
            node = node.next;  // перехід до наступного вузла
        }
    }

    public void clear() {  //очищає колекцію
        array = new Node[5];  //створення нового пустого масиву з початковим розміром
        size = 0; //очищуємо
    }

    public int size() { //повертає розмір колекції
        return size;
    }

    public Object get(Object key) {  //повертає значення (Object value) за ключем
        int hash = key.hashCode();  //хеш код ключа
        int index = hash & (array.length - 1);  // індекс в масиві за хеш кодом

        Node node = array[index];    // вузол який займає вказаний індекс у масиві
        while (node != null) { // проходимо по однозв'язному списку вузлів за допомогою вайл
            if (node.key.equals(key)) {   //якщо ключі рівні, то повертаємо значення
                return node.value;
            }
            node = node.next; //переходимо до наступного вузла
        }

        return null;  //якщо ключа не знайдено, то повертаємо нал
    }
}

/**
 Хеш таблиця - це структура даних, яка дозволяє ефективно зберігати і шукати дані, в ній дані зберігаються
 у вигляді пар ключ + значення. Основна ідея хеш табоиці полягає в тому, що кожен ключ перетворюється
 у хеш код - ціле число, яке використовується як індекс в масиві. Значення зберігаються за відповідним індексом
 в масиві.
 Хеш код об'єкта використовуються лоя оптимізації роботи зі структурами ланих, які використовують хеш таблиці, ключі
 в хеш таблиці зберігаються у вигляді хеш кодів і при пошуку елемента в хеш таблиці спочатку генерується хеш код
 шуканого елемента, а потім здійснюється пошук за цим хеш кодом.
 Хеш код повинен бути стійким, тобто, якщо два об'єкта рівна за методом іквелс, то їх хеш коди повинні бути однаковими.
 Однак, якщо два об'єкта не рівні за методом іквелс, то їх хеш коди можуть бути різними. Це може призвести до колізій,
 коли два різних об'єкта мають однакові хеш коди, у такому випадку використовуються додаткові методі, щоб розв'язати
 колізію та знайти правильний об'єкт.


Вкладений клас Node, є елементом, що містить дані, а також посилання на наступний
елемент.

Під вузлом в нода розуміється окремий елемент мережі, який може мати своє унікальне ідентифікаційне значення та
виконувати певні функції. Вузол може мати зв'язки з іншими вузлами та обмінюватись даними з ними. У контексті
 розподілених систем або мереж, вузол часто використовується для розподіленої обробки даних.

Нода в Java - це окремий вузол, що входить до складу деякої системи або мережі і виконує основні функції роботи з даними.
 Зазвичай, ноди використовуються для розподіленої обробки даних та спільної роботи декількох частин системи, щоб
 забезпечити високу ефективність та швидкість роботи. Кожна нода може мати власні особливості та може виконувати
 певні функції, такі як зберігання даних, обробка інформації або взаємодія з іншими нодами.
*/
